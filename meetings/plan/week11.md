# Week 11 Status Report - 09/12/20

This week, I have collected more data on ShutTheBox, in particular varying the number of dice in the 12-board variant to investigate the triangular number phenomenon (using 1, 2, 3, 4 and 6 dice). I have also started investigating POMDPs, starting background reading, downloading the development version of PRISM with support for POMDPs and investigating several of the built-in examples (especially McCallum's maze problem).

# Questions/Comments

* Given that this development version of PRISM doesn't support strategy generation, is there any way I can still get the optimal strategy for a particular property? (e.g the sequence of moves taken for McCallum's maze problem)

* I noticed there's also no support for simulating paths manually - do you have any particular tips for debugging POMDPs? I found with ShutTheBox that simulations were really helpful, and I'm concerned about showing my game acts as expected without a few simulations. Converting them to MDPs is trivial and could be partially effective, albeit in some models having hidden information has far larger implications than others.

* I'm coming up with ideas for generating opponents in Liar's Dice, and I have two main ideas at the moment: Either define overall strategies for the entire game (e.g playing safe vs playing agressive), or define strategies for each mechanic of the game (e.g deciding whether or not to challenge) and combine these strategies together to generate opponents. I'm not sure which would be better - the latter would certainly lead to more opponents, and could lead to interesting discussion of a game's mechanics (e.g if different approaches to a mechanic don't impact the game very much, that suggests the mechanic's significance needs to be increased), but it would also be more complex and potentially be less focused than having more bespoke opponents. In either case, I think having deliberately simple opponents is good, so that particular parts of the game can be easily explored and discussed.

* While I started to develop my model, I had an idea - since Liar's Dice is played over a series of rounds, and each round only has a few variables depending on previous rounds (specifically the number of dice for each player, and the starting player), it may be a good idea to consider each round of the game (e.g when player 1 has 3 dice, player 2 has 2 dice, and player 2 is starting) as a separate model, using some sort of preprocessing to generate these rounds, and then combine the results later on (in essence, building a tree of the game where each node represents one particular round). My thinking here is that there will be a lot of duplication between variants of the game after the first few rounds, so this should improve performance by reducing the state space of each model. Moreover, the aforementioned game tree is definitely feasible to visualise (for instance, generating a dot file showing transitions between rounds, in order to show whether the game is heavily dependent on gaining an initial advantage.)