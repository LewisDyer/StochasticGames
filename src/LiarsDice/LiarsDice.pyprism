// Liar's Dice
pomdp

observables
	@ld/list_p1_dice p1_die@
	p1_bid_face, p1_bid_quat, p2_bid_face, p2_bid_quat,
	phase, made_challenge, challenge_correct
endobservables

formula current_bid_face = max(p1_bid_face, p2_bid_face);
formula current_bid_quat = max(p1_bid_quat, p2_bid_quat);

@ld/formulas p1_die p2_die@

// nondeterministic player
module player1
	
	@ld/init_dice p1_die p1@

	p1_bid_face : [0..7] init 0;
	p1_bid_quat : [0..6] init 0;

    @ld/roll_dice p1_die p1@


    @ld/define_init_bid p1_strat p1@
	

	@ld/set_bids p1_strat p1@

endmodule

// dummy player (just designed to show game flow)
module player2

	@ld/init_dice p2_die p2@

	p2_bid_face : [0..6] init 0;
	p2_bid_quat : [0..6] init 0;
	
	@ld/roll_dice p2_die p2@

	@ld/set_bids p2_strat p2@

endmodule

// handles general game state
module controller


	// current phase of a round
	// 0: roll dice
	// 1: starting player bids
	// 2: player 1 makes bid/challenge
	// 3: player 2 makes bid/challenge
	// 4: check challenge result
	// 5: game over, p1 loses
	// 6: game over, p2 loses
	phase : [0..7] init 0;

	made_challenge : [1..2] init 1;

	challenge_correct : bool init true;


    @ld/all_rolled p1_die p2_die@

	[p1_bid_init] phase=1 -> (phase'=3);
	[p1_bid_face] phase=2 -> (phase'=3);
	[p1_bid_quat] phase=2 -> (phase'=3);

	[p1_challenge] phase=2 -> (phase'=4) & (made_challenge' = 1);

	[p2_bid_face] phase=3 -> (phase'=2);
	[p2_bid_quat] phase=3 -> (phase'=2);
	
	[p2_challenge] phase=3 -> (phase'=4) & (made_challenge' = 2);

	[check_challenge_1s] phase=4 & current_bid_face = 1 -> (challenge_correct' = (all_1s >= current_bid_quat)) & (phase'=5);
	[check_challenge_2s] phase=4 & current_bid_face = 2 -> (challenge_correct' = (all_2s >= current_bid_quat)) & (phase'=5);
	[check_challenge_3s] phase=4 & current_bid_face = 3 -> (challenge_correct' = (all_3s >= current_bid_quat)) & (phase'=5);
	[check_challenge_4s] phase=4 & current_bid_face = 4 -> (challenge_correct' = (all_4s >= current_bid_quat)) & (phase'=5);
	[check_challenge_5s] phase=4 & current_bid_face = 5 -> (challenge_correct' = (all_5s >= current_bid_quat)) & (phase'=5);
	[check_challenge_6s] phase=4 & current_bid_face = 6 -> (challenge_correct' = (all_6s >= current_bid_quat)) & (phase'=5);

	[challenge_true_p1] phase=5 & challenge_correct & made_challenge=1 -> (phase'=7);
	[challenge_false_p1] phase=5 & !challenge_correct & made_challenge=1 -> (phase'=6);

	[challenge_true_p2] phase=5 & challenge_correct & made_challenge=2 -> (phase'=6);
	[challenge_false_p2] phase=5 & !challenge_correct & made_challenge=2 -> (phase'=7);

endmodule

label "game_over" = (phase>=6);

label "p1_loses" = (phase=6);
label "p2_loses" = (phase=7);