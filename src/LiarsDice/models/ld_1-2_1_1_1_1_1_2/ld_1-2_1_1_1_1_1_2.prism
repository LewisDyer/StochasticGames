// Liar's Dice
pomdp

observables
	p1_d1,
	p1_bid_face, p1_bid_quat, p2_bid_face, p2_bid_quat,
	phase, made_challenge, challenge_correct
endobservables

const double p1_c;
const double p2_c;

formula current_bid_face = max(p1_bid_face, p2_bid_face);
formula current_bid_quat = max(p1_bid_quat, p2_bid_quat);

formula p1_1s = (p1_d1 = 1 ? 1 : 0);
formula p1_2s = (p1_d1 = 2 ? 1 : 0);
formula p1_3s = (p1_d1 = 3 ? 1 : 0);
formula p1_4s = (p1_d1 = 4 ? 1 : 0);
formula p1_5s = (p1_d1 = 5 ? 1 : 0);
formula p1_6s = (p1_d1 = 6 ? 1 : 0);

formula p2_1s = (p2_d1 = 1 ? 1 : 0) + (p2_d2 = 1 ? 1 : 0);
formula p2_2s = (p2_d1 = 2 ? 1 : 0) + (p2_d2 = 2 ? 1 : 0);
formula p2_3s = (p2_d1 = 3 ? 1 : 0) + (p2_d2 = 3 ? 1 : 0);
formula p2_4s = (p2_d1 = 4 ? 1 : 0) + (p2_d2 = 4 ? 1 : 0);
formula p2_5s = (p2_d1 = 5 ? 1 : 0) + (p2_d2 = 5 ? 1 : 0);
formula p2_6s = (p2_d1 = 6 ? 1 : 0) + (p2_d2 = 6 ? 1 : 0);

formula all_1s = p1_1s + p2_1s;
formula all_2s = p1_2s + p2_2s;
formula all_3s = p1_3s + p2_3s;
formula all_4s = p1_4s + p2_4s;
formula all_5s = p1_5s + p2_5s;
formula all_6s = p1_6s + p2_6s;

formula p1_challenge = ((current_bid_face + current_bid_quat)/9 >= p1_c);
formula p2_challenge = ((current_bid_face + current_bid_quat)/9 >= p2_c);

// nondeterministic player
module player1
	
	p1_d1 : [0..6] init 0;

	p1_bid_face : [0..7] init 0;
	p1_bid_quat : [0..6] init 0;

    [roll_die1] phase=0 & p1_d1 = 0 -> 1/6: (p1_d1'=1)
                                     + 1/6: (p1_d1'=2)
                                     + 1/6: (p1_d1'=3)
                                     + 1/6: (p1_d1'=4)
                                     + 1/6: (p1_d1'=5)
                                     + 1/6: (p1_d1'=6);

    [p1_bid_init] phase=1 -> 1/1: (p1_bid_face' = p1_d1) & (p1_bid_quat' = 1);
	
	[p1_bid_face] phase=2 & p2_bid_face < 6 & !p1_challenge -> (p1_bid_face' = min(p2_bid_face + 1, 6)) & (p1_bid_quat' = current_bid_quat);
	
	[p1_bid_quat] phase=2 & p2_bid_face = 6 & p2_bid_quat < 6 & !p1_challenge -> (p1_bid_quat' = min(p2_bid_quat + 1,3)) & (p1_bid_face' = current_bid_face);

endmodule

// dummy player (just designed to show game flow)
module player2

	p2_d1 : [0..6] init 0;
	p2_d2 : [0..6] init 0;

	p2_bid_face : [0..6] init 0;
	p2_bid_quat : [0..6] init 0;
	
	[roll_die1] phase=0 & p2_d1 = 0 -> 1/6: (p2_d1'=1)
	                                 + 1/6: (p2_d1'=2)
	                                 + 1/6: (p2_d1'=3)
	                                 + 1/6: (p2_d1'=4)
	                                 + 1/6: (p2_d1'=5)
	                                 + 1/6: (p2_d1'=6);
	[roll_die2] phase=0 & p2_d2 = 0 & p2_d1 != 0 -> 1/6: (p2_d2'=1)
	                                              + 1/6: (p2_d2'=2)
	                                              + 1/6: (p2_d2'=3)
	                                              + 1/6: (p2_d2'=4)
	                                              + 1/6: (p2_d2'=5)
	                                              + 1/6: (p2_d2'=6);

	

	[p2_bid_face] phase=3 & p1_bid_face < 6 & !p2_challenge -> (p2_bid_face' = min(p1_bid_face + 1, 6)) & (p2_bid_quat' = current_bid_quat);
	
	[p2_bid_quat] phase=3 & p1_bid_face = 6 & p1_bid_quat < 6 & !p2_challenge -> (p2_bid_quat' = min(p1_bid_quat + 1,3)) & (p2_bid_face' = current_bid_face);

endmodule

// handles general game state
module controller

	// current phase of a round
	// 0: roll dice
	// 1: starting player bids
	// 2: player 1 makes bid/challenge
	// 3: player 2 makes bid/challenge
	// 4: check challenge result
	// 5: game over, p1 loses
	// 6: game over, p2 loses
	phase : [0..7] init 0;

	made_challenge : [1..2] init 1;

	challenge_correct : bool init true;

    [all_rolled] phase=0 & p2_d2 != 0 -> (phase'=1);

	[p1_bid_init] phase=1 -> (phase' = 3);

	[p1_bid_face] phase=2 -> (phase'=3);
	[p1_bid_quat] phase=2 -> (phase'=3);

	[p1_challenge] phase=2 -> (phase'=4) & (made_challenge' = 1);

	[p2_bid_face] phase=3 -> (phase'=2);
	[p2_bid_quat] phase=3 -> (phase'=2);
	
	[p2_challenge] phase=3 -> (phase'=4) & (made_challenge' = 2);

	[check_challenge_1s] phase=4 & current_bid_face = 1 -> (challenge_correct' = (all_1s >= current_bid_quat)) & (phase'=5);
	[check_challenge_2s] phase=4 & current_bid_face = 2 -> (challenge_correct' = (all_2s >= current_bid_quat)) & (phase'=5);
	[check_challenge_3s] phase=4 & current_bid_face = 3 -> (challenge_correct' = (all_3s >= current_bid_quat)) & (phase'=5);
	[check_challenge_4s] phase=4 & current_bid_face = 4 -> (challenge_correct' = (all_4s >= current_bid_quat)) & (phase'=5);
	[check_challenge_5s] phase=4 & current_bid_face = 5 -> (challenge_correct' = (all_5s >= current_bid_quat)) & (phase'=5);
	[check_challenge_6s] phase=4 & current_bid_face = 6 -> (challenge_correct' = (all_6s >= current_bid_quat)) & (phase'=5);

	[challenge_true_p1] phase=5 & challenge_correct & made_challenge=1 -> (phase'=7);
	[challenge_false_p1] phase=5 & !challenge_correct & made_challenge=1 -> (phase'=6);

	[challenge_true_p2] phase=5 & challenge_correct & made_challenge=2 -> (phase'=6);
	[challenge_false_p2] phase=5 & !challenge_correct & made_challenge=2 -> (phase'=7);

endmodule

label "game_over" = (phase>=6);

label "p1_loses" = (phase=6);
label "p2_loses" = (phase=7);

rewards "total_bids"
	[p1_bid_init] true : 1;
	[p1_bid_face] true : 1;
	[p1_bid_quat] true : 1;
	[p2_bid_face] true : 1;
	[p2_bid_quat] true : 1;
endrewards