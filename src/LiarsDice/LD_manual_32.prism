// Liar's Dice
// Manual example: 2 players, 3 dice each, safe strategy.

pomdp


observables
	p1_d1, p2_d2, p3_d3,
	p1_bid_face, p1_bid_quat, p2_bid_face, p2_bid_quat,
	phase, made_challenge, challenge_correct
endobservables

formula current_bid_face = max(p1_bid_face, p2_bid_face);
formula current_bid_quat = max(p1_bid_quat, p2_bid_quat);

formula p1_1s = (p1_d1 = 1 ? 1 : 0) + (p1_d2 = 1 ? 1 : 0) + (p1_d3 = 1 ? 1 : 0);
formula p1_2s = (p1_d1 = 2 ? 1 : 0) + (p1_d2 = 2 ? 1 : 0) + (p1_d3 = 2 ? 1 : 0);
formula p1_3s = (p1_d1 = 3 ? 1 : 0) + (p1_d2 = 3 ? 1 : 0) + (p1_d3 = 3 ? 1 : 0);
formula p1_4s = (p1_d1 = 4 ? 1 : 0) + (p1_d2 = 4 ? 1 : 0) + (p1_d3 = 4 ? 1 : 0);
formula p1_5s = (p1_d1 = 5 ? 1 : 0) + (p1_d2 = 5 ? 1 : 0) + (p1_d3 = 5 ? 1 : 0);
formula p1_6s = (p1_d1 = 6 ? 1 : 0) + (p1_d2 = 6 ? 1 : 0) + (p1_d3 = 6 ? 1 : 0);

formula p2_1s = (p2_d1 = 1 ? 1 : 0) + (p2_d2 = 1 ? 1 : 0);
formula p2_2s = (p2_d1 = 2 ? 1 : 0) + (p2_d2 = 2 ? 1 : 0);
formula p2_3s = (p2_d1 = 3 ? 1 : 0) + (p2_d2 = 3 ? 1 : 0);
formula p2_4s = (p2_d1 = 4 ? 1 : 0) + (p2_d2 = 4 ? 1 : 0);
formula p2_5s = (p2_d1 = 5 ? 1 : 0) + (p2_d2 = 5 ? 1 : 0);
formula p2_6s = (p2_d1 = 6 ? 1 : 0) + (p2_d2 = 6 ? 1 : 0);

formula all_1s = p1_1s + p2_1s;
formula all_2s = p1_2s + p2_2s;
formula all_3s = p1_3s + p2_3s;
formula all_4s = p1_4s + p2_4s;
formula all_5s = p1_5s + p2_5s;
formula all_6s = p1_6s + p2_6s;

// nondeterministic player
module player1
	
	p1_d1 : [0..6] init 0;
	p1_d2 : [0..6] init 0;
	p1_d3 : [0..6] init 0;

	
	p1_bid_face : [0..7] init 0;
	p1_bid_quat : [0..6] init 0;

	[roll_die1] phase=0 & p1_d1=0 -> 1/6: (p1_d1'=1)
				       + 1/6: (p1_d1'=2)
				       + 1/6: (p1_d1'=3)
                                       + 1/6: (p1_d1'=4)
                                       + 1/6: (p1_d1'=5)
                                       + 1/6: (p1_d1'=6);
	[roll_die2] phase=0 & p1_d2=0 & p1_d1 != 0 -> 1/6: (p1_d2'=1)
				       + 1/6: (p1_d2'=2)
				       + 1/6: (p1_d2'=3)
                                       + 1/6: (p1_d2'=4)
                                       + 1/6: (p1_d2'=5)
                                       + 1/6: (p1_d2'=6);
	[roll_die3] phase=0 & p1_d3=0 & p1_d2 != 0 -> 1/6: (p1_d3'=1)
				       + 1/6: (p1_d3'=2)
				       + 1/6: (p1_d3'=3)
                                       + 1/6: (p1_d3'=4)
                                       + 1/6: (p1_d3'=5)
                                       + 1/6: (p1_d3'=6);

	// starting bid: Just take the minimum bid you can see in your hand
	// this should never be 7, since p1_[i]s can't be 0 for all i
	[p1_bid_init] phase=1 -> (p1_bid_face' = min((p1_1s != 0 ? 1 : 7),
		                                (p1_2s != 0 ? 2 : 7),
                                                (p1_3s != 0 ? 3 : 7),
                                                (p1_4s != 0 ? 4 : 7),
                                                (p1_5s != 0 ? 5 : 7),
                                                (p1_6s != 0 ? 6 : 7)
                                               )) & (p1_bid_quat' = 1);

	// very stupid bidding strategy: just keep increasing the face count until you can't, then increase quantity until you can't, then challenge.

	[p1_bid_face] phase=2 & p2_bid_face < 6 -> (p1_bid_face' = min(p2_bid_face + 1, 6)) & (p1_bid_quat' = current_bid_quat);

	[p1_bid_quat] phase=2 & p2_bid_face = 6 & p2_bid_quat < 6 -> (p1_bid_quat' = min(p2_bid_quat + 1, 6)) & (p1_bid_face' = current_bid_face);

endmodule

// dummy player (just designed to show game flow)
module player2

	p2_d1 : [0..6] init 0;
	p2_d2 : [0..6] init 0;
	p2_d3 : [0..6] init 0;

	p2_bid_face : [0..6] init 0;
	p2_bid_quat : [0..6] init 0;
	
	[roll_die1] phase=0 & p2_d1=0 -> 1/6: (p2_d1'=1)
				       + 1/6: (p2_d1'=2)
				       + 1/6: (p2_d1'=3)
                                       + 1/6: (p2_d1'=4)
                                       + 1/6: (p2_d1'=5)
                                       + 1/6: (p2_d1'=6);
	[roll_die2] phase=0 & p2_d2=0 & p2_d1 != 0 -> 1/6: (p2_d2'=1)
				       + 1/6: (p2_d2'=2)
				       + 1/6: (p2_d2'=3)
                                       + 1/6: (p2_d2'=4)
                                       + 1/6: (p2_d2'=5)
                                       + 1/6: (p2_d2'=6);

	[p2_bid_face] phase=3 & p1_bid_face < 6 -> (p2_bid_face' = min(current_bid_face + 1, 6)) & (p2_bid_quat' = current_bid_quat);

	[p2_bid_quat] phase=3 & p1_bid_face = 6 & p1_bid_quat < 6 -> (p2_bid_quat' = min(current_bid_quat + 1, 6)) & (p2_bid_face' = current_bid_face);

endmodule

// handles general game state
module controller


	// current phase of a round
	// 0: roll dice
	// 1: starting player bids
	// 2: player 1 makes bid/challenge
	// 3: player 2 makes bid/challenge
	// 4: check challenge result
	// 5: game over, p1 loses
	// 6: game over, p2 loses
	phase : [0..7] init 0;

	made_challenge : [1..2] init 1;

	challenge_correct : bool init true;

	[all_rolled] phase=0 & p1_d3 != 0 -> (phase'=1);

	[p1_bid_init] phase=1 -> (phase'=3);
	[p1_bid_face] phase=2 & p2_bid_face < 6 -> (phase'=3);
	[p1_bid_quat] phase=2 & p2_bid_face = 6 & p2_bid_quat < 6 -> (phase'=3);

	[p1_challenge] phase=2 & p2_bid_face = 6 & p2_bid_quat = 6 -> (phase'=4) & (made_challenge' = 1);

	[p2_bid_face] phase=3 & p1_bid_face < 6 -> (phase'=2);
	[p2_bid_quat] phase=3 & p1_bid_face = 6 & p1_bid_quat < 6 -> (phase'=2);
	
	[p2_challenge] phase=3 & p1_bid_face = 6 & p1_bid_quat = 6 -> (phase'=4) & (made_challenge' = 2);

	[check_challenge_1s] phase=4 & current_bid_face = 1 -> (challenge_correct' = (all_1s >= current_bid_quat)) & (phase'=5);
	[check_challenge_2s] phase=4 & current_bid_face = 2 -> (challenge_correct' = (all_2s >= current_bid_quat)) & (phase'=5);
	[check_challenge_3s] phase=4 & current_bid_face = 3 -> (challenge_correct' = (all_3s >= current_bid_quat)) & (phase'=5);
	[check_challenge_4s] phase=4 & current_bid_face = 4 -> (challenge_correct' = (all_4s >= current_bid_quat)) & (phase'=5);
	[check_challenge_5s] phase=4 & current_bid_face = 5 -> (challenge_correct' = (all_5s >= current_bid_quat)) & (phase'=5);
	[check_challenge_6s] phase=4 & current_bid_face = 6 -> (challenge_correct' = (all_6s >= current_bid_quat)) & (phase'=5);

	[challenge_true_p1] phase=5 & challenge_correct & made_challenge=1 -> (phase'=7);
	[challenge_false_p1] phase=5 & !challenge_correct & made_challenge=1 -> (phase'=6);

	[challenge_true_p2] phase=5 & challenge_correct & made_challenge=2 -> (phase'=6);
	[challenge_false_p2] phase=5 & !challenge_correct & made_challenge=2 -> (phase'=7);

endmodule

label "game_over" = (phase>=6);

label "p1_loses" = (phase=6);
label "p2_loses" = (phase=7);