// Manual model for 26 Point 2
// 2 players, 4d6 each, 30 spaces.

mdp

const int no_spaces = 100; // goal space to win game
const int no_dice = 4; // max no of dice players can roll a turn
const int no_sides = 6; // number of sides per die

formula p1_end = p1_move > p1_pos;
formula game_over = p1_end;

formula p1_pairs = ((p1_1s >= 2) ? 1 : 0) + ((p1_2s >= 2) ? 1 : 0) + ((p1_3s >= 2) ? 1 : 0) + ((p1_4s >= 2) ? 1 : 0) + ((p1_5s >= 2) ? 1 : 0) + ((p1_6s >= 2) ? 1 : 0);

formula p1_bust = (p1_pairs >= 2) | (p1_1s >= 3) | (p1_2s >= 3) | (p1_3s >= 3) | (p1_4s >= 3) | (p1_5s >= 3) | (p1_6s >= 3);

formula p1_move = p1_bust ? 0 : (1 * p1_1s + 2 * p1_2s + 3 * p1_3s + 4 * p1_4s + 5 * p1_5s + 6 * p1_6s);

formula p1_end_pos = p1_pos + (p1_end ? no_spaces : 0);

module player1
    p1_pos : [0..no_spaces-1] init 0;
    p1_chosen_dice : [1..no_dice] init 1;

    p1_1s : [0..no_dice] init 0;
    p1_2s : [0..no_dice] init 0;
    p1_3s : [0..no_dice] init 0;
    p1_4s : [0..no_dice] init 0;
    p1_5s : [0..no_dice] init 0;
    p1_6s : [0..no_dice] init 0;

    [pick_dice] state=0 ->
        1/2 : (p1_chosen_dice' = 3) +
        1/2 : (p1_chosen_dice' = 4);
    
    [roll_d1] state=1 & p1_chosen_dice >= 1 ->
        1/6 : (p1_1s' = min(p1_1s + 1, no_dice)) +
        1/6 : (p1_2s' = min(p1_2s + 1, no_dice)) + 
        1/6 : (p1_3s' = min(p1_3s + 1, no_dice)) +
        1/6 : (p1_4s' = min(p1_4s + 1, no_dice)) + 
        1/6 : (p1_5s' = min(p1_5s + 1, no_dice)) +
        1/6 : (p1_6s' = min(p1_6s + 1, no_dice));

    [roll_d2] state=2 & p1_chosen_dice >= 2 ->
        1/6 : (p1_1s' = min(p1_1s + 1, no_dice)) +
        1/6 : (p1_2s' = min(p1_2s + 1, no_dice)) + 
        1/6 : (p1_3s' = min(p1_3s + 1, no_dice)) +
        1/6 : (p1_4s' = min(p1_4s + 1, no_dice)) + 
        1/6 : (p1_5s' = min(p1_5s + 1, no_dice)) +
        1/6 : (p1_6s' = min(p1_6s + 1, no_dice));

    [roll_d2] state=2 & p1_chosen_dice < 2 -> true;

    [roll_d3] state=3 & p1_chosen_dice >= 3 ->
        1/6 : (p1_1s' = min(p1_1s + 1, no_dice)) +
        1/6 : (p1_2s' = min(p1_2s + 1, no_dice)) + 
        1/6 : (p1_3s' = min(p1_3s + 1, no_dice)) +
        1/6 : (p1_4s' = min(p1_4s + 1, no_dice)) + 
        1/6 : (p1_5s' = min(p1_5s + 1, no_dice)) +
        1/6 : (p1_6s' = min(p1_6s + 1, no_dice));

    [roll_d3] state=3 & p1_chosen_dice < 3 -> true;

    [roll_d4] state=4 & p1_chosen_dice >= 4 ->
        1/6 : (p1_1s' = min(p1_1s + 1, no_dice)) +
        1/6 : (p1_2s' = min(p1_2s + 1, no_dice)) + 
        1/6 : (p1_3s' = min(p1_3s + 1, no_dice)) +
        1/6 : (p1_4s' = min(p1_4s + 1, no_dice)) + 
        1/6 : (p1_5s' = min(p1_5s + 1, no_dice)) +
        1/6 : (p1_6s' = min(p1_6s + 1, no_dice));
    
    [roll_d4] state=4 & p1_chosen_dice < 4 -> true;

    [move_roll] state=5 -> (p1_pos' = mod(p1_pos + (p1_bust ? 0 : p1_move), no_spaces));

    [pick_wins] state=6 -> (p1_1s' = 0) & (p1_2s' = 0) & (p1_3s' = 0) & (p1_4s' = 0) & (p1_5s' = 0) & (p1_6s' = 0);
endmodule

module board

    // Local state:
    // 0: choosing how many dice to roll
    // 1: roll dice1
    // 2: roll dice2
    // 3: roll dice3
    // 4: roll dice4
    // 5: Moving (if allowed!)
    // 6: Deciding winner
    // 7: game over
    state : [0..8] init 0;

    [pick_dice] state=0 -> (state'=1);
    [roll_d1] state=1 -> (state'=2);
    [roll_d2] state=2 -> (state'=3);
    [roll_d3] state=3 -> (state'=4);
    [roll_d4] state=4 -> (state'=5);
    [move_roll] state=5 -> (state'=6);

    [pick_wins] state=6 & !game_over -> (state'=0);
    [pick_wins] state=6 & game_over -> (state'=7);


    [game_over] state=7 -> (state'=7);


endmodule

label "game_over" = (state=7);

label "p1_bust" = p1_bust;

rewards "no_rounds"
	[pick_dice] true: 1;
endrewards

rewards "p1_busts"
	(state=5) & (p1_bust) : 1;
endrewards