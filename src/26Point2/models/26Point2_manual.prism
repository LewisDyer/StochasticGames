// Manual model for 26 Point 2
// 2 players, 4d6 each, 30 spaces.

mdp

const int no_spaces = 30; // goal space to win game
const int no_dice = 4; // max no of dice players can roll a turn
const int no_sides = 6; // number of sides per die

formula p1_end = p1_move > p1_pos;
formula p2_end = p2_move > p2_pos;
formula game_over = p1_end | p2_end;

formula p1_pairs = ((p1_1s >= 2) ? 1 : 0) + ((p1_2s >= 2) ? 1 : 0) + ((p1_3s >= 2) ? 1 : 0) + ((p1_4s >= 2) ? 1 : 0) + ((p1_5s >= 2) ? 1 : 0) + ((p1_6s >= 2) ? 1 : 0);
formula p2_pairs = ((p2_1s >= 2) ? 1 : 0) + ((p2_2s >= 2) ? 1 : 0) + ((p2_3s >= 2) ? 1 : 0) + ((p2_4s >= 2) ? 1 : 0) + ((p2_5s >= 2) ? 1 : 0) + ((p2_6s >= 2) ? 1 : 0);

formula p1_bust = (p1_pairs >= 2) | (p1_1s >= 3) | (p1_2s >= 3) | (p1_3s >= 3) | (p1_4s >= 3) | (p1_5s >= 3) | (p1_6s >= 3);
formula p2_bust = (p2_pairs >= 2) | (p2_1s >= 3) | (p2_2s >= 3) | (p2_3s >= 3) | (p2_4s >= 3) | (p2_5s >= 3) | (p2_6s >= 3);

formula p1_move = p1_bust ? 0 : (1 * p1_1s + 2 * p1_2s + 3 * p1_3s + 4 * p1_4s + 5 * p1_5s + 6 * p1_6s);
formula p2_move = p2_bust ? 0 : (1 * p2_1s + 2 * p2_2s + 3 * p2_3s + 4 * p2_4s + 5 * p2_5s + 6 * p2_6s);

formula p1_end_pos = p1_pos + (p1_end ? no_spaces : 0);
formula p2_end_pos = p2_pos + (p2_end ? no_spaces : 0);

module player1
    p1_pos : [0..no_spaces-1] init 0;
    p1_chosen_dice : [1..no_dice] init 1;

    p1_1s : [0..no_dice] init 0;
    p1_2s : [0..no_dice] init 0;
    p1_3s : [0..no_dice] init 0;
    p1_4s : [0..no_dice] init 0;
    p1_5s : [0..no_dice] init 0;
    p1_6s : [0..no_dice] init 0;

    [pick_dice] state=0 ->
        1/2 : (p1_chosen_dice' = 3) +
        1/2 : (p1_chosen_dice' = 4);
    
    [roll_d1] state=1 & p1_chosen_dice >= 1 ->
        1/6 : (p1_1s' = min(p1_1s + 1, no_dice)) +
        1/6 : (p1_2s' = min(p1_2s + 1, no_dice)) + 
        1/6 : (p1_3s' = min(p1_3s + 1, no_dice)) +
        1/6 : (p1_4s' = min(p1_4s + 1, no_dice)) + 
        1/6 : (p1_5s' = min(p1_5s + 1, no_dice)) +
        1/6 : (p1_6s' = min(p1_6s + 1, no_dice));

    [roll_d2] state=2 & p1_chosen_dice >= 2 ->
        1/6 : (p1_1s' = min(p1_1s + 1, no_dice)) +
        1/6 : (p1_2s' = min(p1_2s + 1, no_dice)) + 
        1/6 : (p1_3s' = min(p1_3s + 1, no_dice)) +
        1/6 : (p1_4s' = min(p1_4s + 1, no_dice)) + 
        1/6 : (p1_5s' = min(p1_5s + 1, no_dice)) +
        1/6 : (p1_6s' = min(p1_6s + 1, no_dice));

    [roll_d2] state=2 & p1_chosen_dice < 2 -> true;

    [roll_d3] state=3 & p1_chosen_dice >= 3 ->
        1/6 : (p1_1s' = min(p1_1s + 1, no_dice)) +
        1/6 : (p1_2s' = min(p1_2s + 1, no_dice)) + 
        1/6 : (p1_3s' = min(p1_3s + 1, no_dice)) +
        1/6 : (p1_4s' = min(p1_4s + 1, no_dice)) + 
        1/6 : (p1_5s' = min(p1_5s + 1, no_dice)) +
        1/6 : (p1_6s' = min(p1_6s + 1, no_dice));

    [roll_d3] state=3 & p1_chosen_dice < 3 -> true;

    [roll_d4] state=4 & p1_chosen_dice >= 4 ->
        1/6 : (p1_1s' = min(p1_1s + 1, no_dice)) +
        1/6 : (p1_2s' = min(p1_2s + 1, no_dice)) + 
        1/6 : (p1_3s' = min(p1_3s + 1, no_dice)) +
        1/6 : (p1_4s' = min(p1_4s + 1, no_dice)) + 
        1/6 : (p1_5s' = min(p1_5s + 1, no_dice)) +
        1/6 : (p1_6s' = min(p1_6s + 1, no_dice));
    
    [roll_d4] state=4 & p1_chosen_dice < 4 -> true;

    [move_roll] state=5 -> (p1_pos' = mod(p1_pos + (p1_bust ? 0 : p1_move), no_spaces));

    [pick_wins] state=6 -> (p1_1s' = 0) & (p1_2s' = 0) & (p1_3s' = 0) & (p1_4s' = 0) & (p1_5s' = 0) & (p1_6s' = 0);
endmodule


module player2
    p2_pos : [0..no_spaces-1] init 0;
    p2_chosen_dice : [1..no_dice] init 1;

    p2_1s : [0..no_dice] init 0;
    p2_2s : [0..no_dice] init 0;
    p2_3s : [0..no_dice] init 0;
    p2_4s : [0..no_dice] init 0;
    p2_5s : [0..no_dice] init 0;
    p2_6s : [0..no_dice] init 0;

    [p2_pick_dice] state=0 ->
        1/2 : (p2_chosen_dice' = 3) +
        1/2 : (p2_chosen_dice' = 4);


    [p2_roll_d1] state=1 & p2_chosen_dice >= 1 ->
        1/6 : (p2_1s' = min(p2_1s + 1, no_dice)) +
        1/6 : (p2_2s' = min(p2_2s + 1, no_dice)) + 
        1/6 : (p2_3s' = min(p2_3s + 1, no_dice)) +
        1/6 : (p2_4s' = min(p2_4s + 1, no_dice)) + 
        1/6 : (p2_5s' = min(p2_5s + 1, no_dice)) +
        1/6 : (p2_6s' = min(p2_6s + 1, no_dice));

    [p2_roll_d2] state=2 & p2_chosen_dice >= 2 ->
        1/6 : (p2_1s' = min(p2_1s + 1, no_dice)) +
        1/6 : (p2_2s' = min(p2_2s + 1, no_dice)) + 
        1/6 : (p2_3s' = min(p2_3s + 1, no_dice)) +
        1/6 : (p2_4s' = min(p2_4s + 1, no_dice)) + 
        1/6 : (p2_5s' = min(p2_5s + 1, no_dice)) +
        1/6 : (p2_6s' = min(p2_6s + 1, no_dice));

    [p2_roll_d2] state=2 & p2_chosen_dice < 2 -> true;

    [p2_roll_d3] state=3 & p2_chosen_dice >= 3 ->
        1/6 : (p2_1s' = min(p2_1s + 1, no_dice)) +
        1/6 : (p2_2s' = min(p2_2s + 1, no_dice)) + 
        1/6 : (p2_3s' = min(p2_3s + 1, no_dice)) +
        1/6 : (p2_4s' = min(p2_4s + 1, no_dice)) + 
        1/6 : (p2_5s' = min(p2_5s + 1, no_dice)) +
        1/6 : (p2_6s' = min(p2_6s + 1, no_dice));

    [p2_roll_d3] state=3 & p2_chosen_dice < 3 -> true;

    [p2_roll_d4] state=4 & p2_chosen_dice >= 4 ->
        1/6 : (p2_1s' = min(p2_1s + 1, no_dice)) +
        1/6 : (p2_2s' = min(p2_2s + 1, no_dice)) + 
        1/6 : (p2_3s' = min(p2_3s + 1, no_dice)) +
        1/6 : (p2_4s' = min(p2_4s + 1, no_dice)) + 
        1/6 : (p2_5s' = min(p2_5s + 1, no_dice)) +
        1/6 : (p2_6s' = min(p2_6s + 1, no_dice));
    
    [p2_roll_d4] state=4 & p2_chosen_dice < 4 -> true;

    [p2_move_roll] state=5 -> (p2_pos' = mod(p2_pos + (p2_bust ? 0 : p2_move), no_spaces));

    [p2_pick_wins] state=6 -> (p2_1s' = 0) & (p2_2s' = 0) & (p2_3s' = 0) & (p2_4s' = 0) & (p2_5s' = 0) & (p2_6s' = 0); // need to reset after win decision to make sure we terminate

endmodule


module board

    // Local state:
    // 0: choosing how many dice to roll
    // 1: roll dice1
    // 2: roll dice2
    // 3: roll dice3
    // 4: roll dice4
    // 5: Moving (if allowed!)
    // 6: Deciding winner
    // 7: game over
    state : [0..8] init 0;
    winner : [0..3] init 0;

    [pick_dice] state=0 -> (state'=1);
    [roll_d1] state=1 -> (state'=2);
    [roll_d2] state=2 -> (state'=3);
    [roll_d3] state=3 -> (state'=4);
    [roll_d4] state=4 -> (state'=5);
    [move_roll] state=5 -> (state'=6);

    [pick_wins] state=6 & !game_over -> (state'=0);
    [pick_wins] state=6 & game_over & (p1_pos = p2_pos) -> (winner' = (p1_move >= p2_move ? ((p1_move = p2_move) ? 3 : 1) : 2)) & (state' = 7); // if there's a tie, whoever was ahead last round wins
    [pick_wins] state=6 & game_over & (p1_pos != p2_pos) -> (winner' = (((p1_end ? no_spaces : 0) + p1_pos) > ((p2_end ? no_spaces : 0) + p2_pos)) ? 1 : 2) & (state' = 7);

    [] state=7 -> (state'=7);


endmodule

label "p1_wins" = ((state=7) & (winner=1));
label "p2_wins" = ((state=7) & (winner=2));
label "players_tied" = ((state=7) & (winner=3));
label "game_over" = (state=7);

label "p1_bust" = p1_bust;
label "p2_bust" = p2_bust;

rewards "no_rounds"
	[pick_dice] true: 1;
endrewards

rewards "p1_busts"
	(state=5) & (p1_bust) : 1;
endrewards

rewards "p2_busts"
	(state=5) & (p2_bust) : 1;
endrewards
