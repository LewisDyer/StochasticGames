// Modelling Shut the Box using 6 boards and one d6
// "Highest number" strategy for board covering
// Manually created

// turn-based stochastic game

smg

player p1 [die_toss], [cover], [halts] endplayer

formula game_over = (state=3);
formula score = b1*1 + b2*2 + b3*3 + b4*4 + b5*5 + b6*6;

module player1

    // Local state:
    // 0: rolling dice
    // 1: choosing boards to cover
    // 2: no more valid choices to cover, halt
    state: [0..2] init 0;
    // current value on die (with initial 0 state)
    die: [0..6] init 0;
    // boards (0 if uncovered, 1 if covered)
    // note that we use ints instead of bools to make it easier to count the payoffs later
    b1: [0..1] init 0;
    b2: [0..1] init 0;
    b3: [0..1] init 0;
    b4: [0..1] init 0;
    b5: [0..1] init 0;
    b6: [0..1] init 0;

    [die_toss] state=0 -> 1/6:(die'=1) & (state'=1)
                        + 1/6:(die'=2) & (state'=1)
                        + 1/6:(die'=3) & (state'=1)
                        + 1/6:(die'=4) & (state'=1)
                        + 1/6:(die'=5) & (state'=1)
                        + 1/6:(die'=6) & (state'=1);

    // choosing which boards to cover
    // This model is deterministic: we always prefer covering the largest numbers possible.
    [cover] state=1 & die=1 & b1=0 -> (state'=0) & (b1'=1); // cover 1
    [cover] state=1 & die=1 & !(b1=0) -> (state'=2); // no covers

    [cover] state=1 & die=2 & b2=0 -> (state'=0) & (b2'=1); // cover 2
    [cover] state=1 & die=2 & !(b2=0) -> (state'=2); // no covers

    [cover] state=1 & die=3 & b3=0 -> (state'=0) & (b3'=1); // cover 3
    [cover] state=1 & die=3 & !(b3=0) & (b1=0 & b2=0) -> (state'=0) & (b1'=1) & (b2'=1); // cover 1,2
    [cover] state=1 & die=3 & !(b3=0 | (b1=0 & b2=0)) -> (state'=2); // no covers

    [cover] state=1 & die=4 & b4=0 -> (state'=0) & (b4'=1); // cover 4
    [cover] state=1 & die=4 & !(b4=0) & (b1=0 & b3=0) -> (state'=0) & (b1'=1) & (b3'=1); // cover 1,3
    [cover] state=1 & die=4 & !(b4=0 | (b1=0 & b3=0)) -> (state'=2); // no covers

    [cover] state=1 & die=5 & b5=0 -> (state'=0) & (b5'=1); // cover 5
    [cover] state=1 & die=5 & !(b5=0) & (b1=0 & b4=0) -> (state'=0) & (b1'=1) & (b4'=1); // cover 1,4
    [cover] state=1 & die=5 & !(b5=0 | (b1=0 & b4=0)) & (b2=0 & b3=0) -> (state'=0) & (b2'=1) & (b3'=1); // cover 2,3
    [cover] state=1 & die=5 & !(b5=0 | (b1=0 & b4=0) | (b2=0 & b3=0)) -> (state'=2); // no covers

    [cover] state=1 & die=6 & b6=0 -> (state'=0) & (b6'=1); // cover 6
    [cover] state=1 & die=6 & !(b6=0) & (b1=0 & b5=0) -> (state'=0) & (b1'=1) & (b5'=1); // cover 1,5
    [cover] state=1 & die=6 & !(b6=0 | (b1=0 & b5=0)) & (b2=0 & b4=0) -> (state'=0) & (b2'=1) & (b4'=1); // cover 2,4
    [cover] state=1 & die=6 & !(b6=0 | (b1=0 & b5=0) | (b2=0 & b4=0)) & (b1=0 & b2=0 & b3=0) -> (state'=0) & (b1'=1) & (b2'=1) & (b3'=1); // cover 1,2,3
    [cover] state=1 & die=6 & !(b6=0 | (b1=0 & b5=0) | (b2=0 & b4=0) | (b1=0 & b2=0 & b3=0)) -> (state'=2); // no covers

    [count] state=2 -> (state'=3);

    [halts] state=3 -> true;

endmodule

rewards "total_boards"
    state=2 : score;
endrewards

rewards "no_rolls"
    state=0: 1;
endrewards